// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var BoardCtrl,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.ticTacToe = angular.module('TicTacToe', ["firebase"]);

  ticTacToe.constant('WIN_PATTERNS', [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]);

  BoardCtrl = (function() {
    BoardCtrl.prototype.uniqueId = function(length) {
      var id;
      if (length == null) {
        length = 8;
      }
      id = "";
      while (id.length < length) {
        id += Math.random().toString(36).substr(2);
      }
      return id.substr(0, length);
    };

    function BoardCtrl($scope, WIN_PATTERNS, $firebase) {
      this.WIN_PATTERNS = WIN_PATTERNS;
      this.makeMove = __bind(this.makeMove, this);
      this.parseBoard = __bind(this.parseBoard, this);
      this.announceTie = __bind(this.announceTie, this);
      this.announceWinner = __bind(this.announceWinner, this);
      this.gameUnwinnable = __bind(this.gameUnwinnable, this);
      this.rowStillWinnable = __bind(this.rowStillWinnable, this);
      this.movesRemaining = __bind(this.movesRemaining, this);
      this.getRow = __bind(this.getRow, this);
      this.getPatterns = __bind(this.getPatterns, this);
      this.startGame = __bind(this.startGame, this);
      this.resetBoard = __bind(this.resetBoard, this);
      this.runGame = __bind(this.runGame, this);
      this.numberOfMoves = __bind(this.numberOfMoves, this);
      this.setUpGame = __bind(this.setUpGame, this);
      this.scope = $scope;
      this.firebase = $firebase;
      this.scope.startGame = this.startGame;
      this.scope.makeMove = this.makeMove;
      this.scope.gameOn = false;
      this.scope.myMove = false;
      this.resetBoard();
      this.pendingGameRef = new Firebase("https://tictactoe-lau.firebaseio.com/tictactoe/pendingGame");
    }

    BoardCtrl.prototype.setUpGame = function(pendingGame) {
      if (pendingGame) {
        this.gameId = pendingGame;
        this.player = 1;
        this.scope.myMove = true;
        return null;
      } else {
        this.gameId = this.uniqueId();
        this.player = 0;
        return this.gameId;
      }
    };

    BoardCtrl.prototype.numberOfMoves = function() {
      return Object.keys(this.scope.cells).filter(function(k) {
        return k.length === 1;
      }).length;
    };

    BoardCtrl.prototype.runGame = function(error, committed, snapshot) {
      this.boardRef = new Firebase("https://tictactoe-lau.firebaseio.com/tictactoe/games/" + this.gameId + "/board");
      this.board = this.firebase(this.boardRef);
      this.board.$bind(this.scope, 'cells').then((function(_this) {
        return function(unbind) {
          _this.unbindCells = unbind;
          return _this.scope.gameOn = true;
        };
      })(this));
      return this.board.$on("change", (function(_this) {
        return function() {
          _this.scope.myMove = (_this.numberOfMoves() + 1) % 2 === _this.player;
          return _this.parseBoard();
        };
      })(this));
    };

    BoardCtrl.prototype.resetBoard = function() {
      this.gameId = null;
      if (this.unbindCells) {
        this.unbindCells();
      }
      this.scope.cells = {};
      return this.scope.winningCells = {};
    };

    BoardCtrl.prototype.startGame = function() {
      this.resetBoard();
      return this.pendingGameRef.transaction(this.setUpGame, this.runGame, true);
    };

    BoardCtrl.prototype.getPatterns = function() {
      return this.patternsToTest = this.WIN_PATTERNS.filter(function() {
        return true;
      });
    };

    BoardCtrl.prototype.getRow = function(pattern) {
      var c, c0, c1, c2;
      c = this.scope.cells;
      c0 = c[pattern[0]] || pattern[0];
      c1 = c[pattern[1]] || pattern[1];
      c2 = c[pattern[2]] || pattern[2];
      return "" + c0 + c1 + c2;
    };

    BoardCtrl.prototype.someoneWon = function(row) {
      return 'xxx' === row || 'ooo' === row;
    };

    BoardCtrl.prototype.isMixedRow = function(row) {
      return row.match(/o+\d?x+|x+\d?o+/i) != null;
    };

    BoardCtrl.prototype.hasOneX = function(row) {
      return row.match(/x\d\d|\dx\d|\d\dx/i) != null;
    };

    BoardCtrl.prototype.hasTwoXs = function(row) {
      return row.match(/xx\d|x\dx|\dxx/i) != null;
    };

    BoardCtrl.prototype.hasOneO = function(row) {
      return row.match(/o\d\d|\do\d|\d\do/i) != null;
    };

    BoardCtrl.prototype.hasTwoOs = function(row) {
      return row.match(/oo\d|o\do|\doo/i) != null;
    };

    BoardCtrl.prototype.isEmptyRow = function(row) {
      return row.match(/\d\d\d/i) != null;
    };

    BoardCtrl.prototype.movesRemaining = function(player) {
      var totalMoves;
      totalMoves = 9 - this.numberOfMoves();
      if (player === 1) {
        return Math.ceil(totalMoves / 2);
      } else if (player === 0) {
        return Math.floor(totalMoves / 2);
      } else {
        return totalMoves;
      }
    };

    BoardCtrl.prototype.rowStillWinnable = function(row) {
      return !(this.isMixedRow(row) || (this.hasOneX(row) && this.movesRemaining(1) < 2) || (this.hasTwoXs(row) && this.movesRemaining(1) < 1) || (this.hasOneO(row) && this.movesRemaining(0) < 2) || (this.hasTwoOs(row) && this.movesRemaining(0) < 1) || (this.isEmptyRow(row) && this.movesRemaining() < 5));
    };

    BoardCtrl.prototype.gameUnwinnable = function() {
      return this.patternsToTest.length < 1;
    };

    BoardCtrl.prototype.announceWinner = function(winningPattern) {
      var k, v, winner, _ref, _ref1;
      winner = this.scope.cells[winningPattern[0]];
      _ref = this.scope.cells;
      for (k in _ref) {
        v = _ref[k];
        this.scope.winningCells[k] = k.length === 1 && (_ref1 = parseInt(k), __indexOf.call(winningPattern, _ref1) >= 0) ? 'win' : 'unwin';
      }
      this.scope.theWinnerIs = winner;
      return this.scope.gameOn = false;
    };

    BoardCtrl.prototype.announceTie = function() {
      this.scope.cats = true;
      return this.scope.gameOn = false;
    };

    BoardCtrl.prototype.parseBoard = function() {
      var winningPattern;
      winningPattern = false;
      this.patternsToTest = this.WIN_PATTERNS.filter((function(_this) {
        return function(pattern) {
          var row;
          row = _this.getRow(pattern);
          if (_this.someoneWon(row)) {
            winningPattern || (winningPattern = pattern);
          }
          return _this.rowStillWinnable(row);
        };
      })(this));
      if (winningPattern) {
        return this.announceWinner(winningPattern);
      } else if (this.gameUnwinnable()) {
        return this.announceTie();
      }
    };

    BoardCtrl.prototype.makeMove = function($event) {
      var cell;
      this.$event = $event;
      cell = this.$event.target.dataset.index;
      if (this.scope.gameOn && !this.scope.cells[cell] && this.scope.myMove) {
        this.scope.cells[cell] = this.player === 1 ? 'x' : 'o';
        return this.scope.myMove = false;
      }
    };

    return BoardCtrl;

  })();

  BoardCtrl.$inject = ["$scope", "WIN_PATTERNS", "$firebase"];

  ticTacToe.controller("BoardCtrl", BoardCtrl);

}).call(this);

//# sourceMappingURL=application.map
